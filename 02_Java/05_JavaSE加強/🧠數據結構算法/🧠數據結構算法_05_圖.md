# 數據結構算法_05_圖
![[數據結構算法_05_圖_01_無向圖.png]]

- 定義：圖是由頂點的有窮非空集合和頂點之間邊的集合組成
- 常見術語：
	- 相鄰頂點：兩個頂點通過一條邊相連，此時這兩個頂點互為相鄰頂點
	- 度：有幾條邊依附這個頂點
	- 子圖：大圖所包含的好幾個小圖，這些小圖叫子圖
	- 路徑：從一個頂點到另一個頂點要經過的頂點數
	- 環：起點和終點相同
	- 連通圖：圖中所有的頂點都相連(直接/間接)
	- 連通子圖：非連通圖有幾個連通圖組成，這些連通圖叫連通子圖

## 🧠鄰接矩陣 Adjacency Matrix
鄰接矩陣是用二維數組來表示有限圖。每個元素代表各點之間是否有邊相連，0代表不相連，1代表相連。此做法的缺點是會使用到很多內存空間。
![[數據結構算法_05_圖_02_鄰接矩陣.png]]

## 🧠鄰接表 Adjacency List
對於圖中的每個頂點，將儲存所有其它與之相連的頂點
![[數據結構算法_05_圖_03_鄰接表.png]]

| 變量/方法 | API設計                                                                                                                                                                                                                                      |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T145_AdjacencyList`                                                                                                                                                                                                                         |
| 構造方法  | `T145_AdjacencyList(int pointCount)`                                                                                                                                                                                                         |
| 成員變量  | `private int pointCount`頂點數量</br>`private int lineCount`邊數量</br>`private T072_Queue<Integer>[] adjList`鄰接表                                                                                                                         |
| 方法      | `public int getPointCount()`取得圖中頂點數</br>`getLineCount()`取得圖中邊數</br>`public void addLine(Integer point1, Integer point2)`在兩頂點間新增邊</br>`public T072_Queue<Integer> getLineByPoint(Integer point)`取得與指定頂點相連的頂點 |

```java
public class T145_AdjacencyList {
    // 頂點數量
    private int pointCount;
    // 邊數量
    private int lineCount;
    // 鄰接表
    private T072_Queue<Integer>[] adjList;

    public T145_AdjacencyList(int pointCount) {
        super();
        this.pointCount = pointCount;
        this.lineCount = 0;
        this.adjList = new T072_Queue[pointCount];
        for (int i = 0; i < this.adjList.length; i++) {
            this.adjList[i] = new T072_Queue<Integer>();
        }
    }

    /**
     * 取得圖中頂點數
     * 
     * @return
     */
    public int getPointCount() {
        return this.pointCount;
    }

    /**
     * 取得圖中邊數
     * 
     * @return
     */
    public int getLineCount() {
        return this.lineCount;
    }

    /**
     * 在兩頂點間新增邊
     * 
     * @param point1
     * @param point2
     */
    public void addLine(Integer point1, Integer point2) {
        // 兩頂點必須在鄰接表中
        if (point1 >= this.adjList.length || point2 >= this.adjList.length) {
            return;
        }
        // 兩頂點必須相互沒連接
        Iterator<Integer> iterator1 = this.adjList[point1].iterator();
        Iterator<Integer> iterator2 = this.adjList[point2].iterator();
        while (iterator1.hasNext()) {
            if (iterator1.next() == point2) {
                return;
            }
        }
        while (iterator2.hasNext()) {
            if (iterator2.next() == point1) {
                return;
            }
        }
        // 兩頂點新增邊
        this.adjList[point1].enqueue(point2);
        this.adjList[point2].enqueue(point1);
        this.lineCount++;
    }

    /**
     * 取得與指定頂點相連的頂點
     * 
     * @param point
     * @return
     */
    public T072_Queue<Integer> getLineByPoint(Integer point) {
        return this.adjList[point];
    }

    @Override
    public String toString() {
        String returnFormat = "T145_AdjacencyList [\n\tpointCount=%s, \n\t" + "lineCount=%s, \n\t" + "adjList=\n%s\n]";
        String queueFormat = "\t\t%s , T072_Queue [%s]";
        List<String> queueStrList = new ArrayList<String>();
        for (int i = 0; i < this.adjList.length; i++) {
            List<String> tempStrList = new ArrayList<String>();
            Iterator<Integer> iterator = this.adjList[i].iterator();
            while (iterator.hasNext()) {
                tempStrList.add(Integer.toString(iterator.next()));
            }
            queueStrList.add(String.format(queueFormat, i, String.join(", ", tempStrList)));
        }
        return String.format(returnFormat, this.pointCount, this.lineCount, String.join(", \n", queueStrList));
    }
}
```

## 🧠圖的搜索
### 深度優先搜索
在搜索時遇到一個頂點有子節點又有兄弟節點，則先找子節點，再找兄弟節點

| 變量/方法 | API設計                                                                                                                                                                                                                                                 |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T147_DepthFirstSearch`                                                                                                                                                                                                                                 |
| 構造方法  | `T147_DepthFirstSearch(T145_AdjacencyList adjList, Integer searchPoint)`                                                                                                                                                                                |
| 成員變量  | `private boolean[] isSearched`頂點是否被搜索過註記</br>`private int connectCount`有多少頂點與指定頂點相連                                                                                                                                               |
| 方法      | `private void getConnectPoint(T145_AdjacencyList adjList, Integer point)`取得與起始頂點相通的頂點</br>`public boolean isConnectWithSearchPoint(Integer point)`判斷指定點是否與起始頂點相連</br>`getConnectSearchPointCount()`取得與起始頂點相連的頂點數 |

```java
public class T147_DepthFirstSearch {
    // 頂點是否被搜索過註記
    private boolean[] isSearched;
    // 有多少頂點與指定頂點相連
    private int connectCount;

    public T147_DepthFirstSearch(T145_AdjacencyList adjList, Integer searchPoint) {
        super();
        this.isSearched = new boolean[adjList.getPointCount()];
        this.connectCount = 0;
        this.getConnectPoint(adjList, searchPoint);
    }

    /**
     * 取得與指定頂點相通的頂點
     * 
     * @param adjList
     * @param point
     */
    private void getConnectPoint(T145_AdjacencyList adjList, Integer point) {
        // 圖中無查詢頂點
        if (point >= adjList.getPointCount()) {
            return;
        }
        this.isSearched[point] = true;
        // 查詢相連頂點
        for (Integer nextPoint : adjList.getLineByPoint(point)) {
            // 下個頂點若被搜索過，則跳過
            if (this.isSearched[nextPoint]) {
                continue;
            }
            this.getConnectPoint(adjList, nextPoint);
        }
        this.connectCount++;
    }

    /**
     * 判斷指定點是否與起始頂點相連
     * 
     * @param point
     * @return
     */
    public boolean isConnectWithSearchPoint(Integer point) {
        return this.isSearched[point];
    }

    /**
     * 取得與起始頂點相連的頂點數
     * 
     * @return
     */
    public int getConnectSearchPointCount() {
        return this.connectCount;
    }
}
```

### 廣度優先搜索
在搜索時遇到一個頂點有子節點又有兄弟節點，則先找兄弟節點，再找子節點；實現方法與二叉樹層序遍歷類似(可參考：[[🧠數據結構算法_04_樹]])。

| 變量/方法 | API設計                                                                                                                                                                                                                                                            |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 類        | `T150_BreadthFirstSearch`                                                                                                                                                                                                                                          |
| 構造方法  | `T150_BreadthFirstSearch(T145_AdjacencyList adjList, Integer searchPoint)`                                                                                                                                                                                         |
| 成員變量  | `private boolean[] isSearched`頂點是否被搜索過註記</br>`private int connectCount`有多少頂點與指定頂點相連</br>`private T072_Queue<Integer> searchWaitList`==等待查詢列表==                                                                                         |
| 方法      | `private void getConnectPoint(T145_AdjacencyList adjList, Integer point)`取得與起始頂點相通的頂點</br>`public boolean isConnectWithSearchPoint(Integer point)`判斷指定點是否與起始頂點相連</br>`public int getConnectSearchPointCount()`取得與起始頂點相連的頂點數 |

```java
/**
 * 取得與指定頂點相通的頂點
 * 
 * @param adjList
 * @param point
 */
private void getConnectPoint(T145_AdjacencyList adjList, Integer point) {
	// 圖中無查詢頂點
	if (point >= adjList.getPointCount()) {
		return;
	}
	// 頂點無子節點
	if (adjList.getLineByPoint(point).getLen() == 0) {
		return;
	}
	this.isSearched[point] = true;
	// 先將所有兄弟節點加入待查詢列表
	for (Integer nextPoint : adjList.getLineByPoint(point)) {
		this.searchWaitList.enqueue(nextPoint);
	}
	// 依序查詢待查詢列表的相連頂點
	while (this.searchWaitList.getLen() > 0) {
		Integer searchPoint = this.searchWaitList.dequeue();
		// 頂點若被搜索過，則跳過
		if (this.isSearched[searchPoint]) {
			continue;
		}
		this.getConnectPoint(adjList, searchPoint);
	}
	this.connectCount++;
}
```

## 🧠路徑查找
| 變量/方法 | API設計                                                                                                                                                                                                                                                     |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T153_DepthFirstPaths`                                                                                                                                                                                                                                      |
| 構造方法  | `T153_DepthFirstPaths(T145_AdjacencyList adjList, Integer startPoint)`                                                                                                                                                                                      |
| 成員變量  | `private boolean[] isSearched`頂點是否被搜索過註記</br>`private int startPoint`查詢起點</br>`private int[] priviousPoint`索引代表頂點，值代表起來到此頂路的上個一頂點                                                                                       |
| 方法      | `private void getConnectPoint(T145_AdjacencyList adjList, Integer point)`取得與起始頂點相通的頂點</br>`public boolean isSamePath(int point1, int point2)`判斷兩頂點是否在同一路徑</br>`public T066_Stack<Integer> getPath(int point)`取得起點到指定點的路徑 |

```java
public class T153_DepthFirstPaths {
    // 查詢起點
    private int startPoint;
    // 頂點是否被搜索過註記
    private boolean[] isSearched;
    // 索引代表頂點，值代表起來到此頂路的上個一頂點
    private int[] priviousPoint;

    public T153_DepthFirstPaths(T145_AdjacencyList adjList, int startPoint) {
        super();
        this.startPoint = startPoint;
        this.isSearched = new boolean[adjList.getPointCount()];
        this.priviousPoint = new int[adjList.getPointCount()];
        this.priviousPoint[startPoint] = -1;// 表示起點
        this.getConnectPoint(adjList, startPoint);
    }

    /**
     * 取得與指定頂點相通的頂點
     * 
     * @param adjList
     * @param point
     */
    private void getConnectPoint(T145_AdjacencyList adjList, int point) {
        // 圖中無查詢頂點
        if (point >= adjList.getPointCount()) {
            return;
        }
        this.isSearched[point] = true;
        for (Integer nextPoint : adjList.getLineByPoint(point)) {
            // 頂點若被搜索過，則跳過
            if (this.isSearched[nextPoint]) {
                continue;
            }
            this.priviousPoint[nextPoint] = point;
            this.getConnectPoint(adjList, nextPoint);
        }
    }

    /**
     * 判斷兩頂點是否在同一路徑
     * 
     * @param point1
     * @param point2
     * @return
     */
    public boolean isSamePath(int point1, int point2) {
        // 取得起點分別到兩個點的路徑
        T066_Stack<Integer> path1 = this.getPath(point1);
        T066_Stack<Integer> path2 = this.getPath(point2);
        // 判斷兩邊路徑是否有另一個頂點
        while (!path1.isEmpty()) {
            if (path1.pop().compareTo(Integer.valueOf(point2)) == 0) {
                return true;
            }
        }
        while (!path2.isEmpty()) {
            if (path2.pop().compareTo(Integer.valueOf(point1)) == 0) {
                return true;
            }
        }
        // 找不到代表不在同一路徑
        return false;
    }

    /**
     * 取得起點到指定點的路徑
     * 
     * @param point
     * @return
     */
    public T066_Stack<Integer> getPath(int point) {
        T066_Stack<Integer> stack = new T066_Stack<Integer>();
        // 圖中無查詢頂點
        if (point >= this.priviousPoint.length) {
            return stack;
        }
        // 指定頂點和起點無連結
        if (!this.isSearched[point]) {
            return stack;
        }
        // 從指定頂點開始找到起點
        int searchPoint = point;
        while (true) {
            stack.push(searchPoint);
            if (this.priviousPoint[searchPoint] == -1) {
                return stack;
            }
            searchPoint = this.priviousPoint[searchPoint];
        }
    }
}
```

# 有向圖 Digraph
![[數據結構算法_05_圖_04_有向圖.png]]
- 常見術語：
	- 出度：由某個頂點指出邊的個數
	- 入度：指向某個頂點的邊個數

| 變量/方法 | API設計                                                                                                                                                                                                                                                                                                      |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 類        | `T158_Digraph`                                                                                                                                                                                                                                                                                               |
| 構造方法  | `public T158_Digraph(int pointCount)`                                                                                                                                                                                                                                                                        |
| 成員變量  | `private int pointCount`頂點數量</br>`private int LineCount`邊的數量</br>`private T072_Queue<Integer>[] adjList`鄰接表                                                                                                                                                                                       |
| 方法      | `public int getPointCount()`取得圖的頂點數</br>`public int getLineCount()`取得圖中邊的數量</br>`public void addLine(int point1, int point2)`添加point1指向point2的邊</br>`public T072_Queue<Integer> getLineByPoint(int point)`取得與指定頂點相連的頂點</br>`private T158_Digraph reverse()`取得該圖的反向圖 |

```java
public class T158_Digraph {
    // 頂點數量
    private int pointCount;
    // 邊的數量
    private int lineCount;
    // 鄰接表
    private T072_Queue<Integer>[] adjList;

    public T158_Digraph(int pointCount) {
        super();
        this.pointCount = pointCount;
        this.lineCount = 0;
        this.adjList = new T072_Queue[pointCount];
        for (int i = 0; i < this.adjList.length; i++) {
            this.adjList[i] = new T072_Queue<Integer>();
        }
    }

    /**
     * 取得圖的頂點數
     * 
     * @return
     */
    public int getPointCount() {
        return this.pointCount;
    }

    /**
     * 取得圖中邊的數量
     * 
     * @return
     */
    public int getLineCount() {
        return this.lineCount;
    }

    /**
     * 添加point1指向point2的邊
     * 
     * @param startPoint
     * @param endPoint
     */
    public void addLine(int startPoint, int endPoint) {
        // 圖中無查詢頂點
        if (startPoint >= this.adjList.length || endPoint >= this.adjList.length) {
            return;
        }
        // 如果startPoint已經指向endPoint，則不做動作
        for (Integer point : this.adjList[startPoint]) {
            if (point == endPoint) {
                return;
            }
        }
        // 向startPoint添加endPoint
        this.adjList[startPoint].enqueue(endPoint);
        this.lineCount++;
    }

    /**
     * 取得與指定頂點相連的頂點
     * 
     * @param point
     * @return
     */
    public T072_Queue<Integer> getLineByPoint(int point) {
        // 取得指定頂點指向的頂點
        T072_Queue<Integer> returnQueue = this.adjList[point];
        // 取得反向圖後，再取得指向指定頂點的頂點
        for (Integer startPoint : this.reverse().adjList[point]) {
            // 如果頂點已經在隊列中，就不重覆加(防止雙向邊)
            boolean isAdded = false;
            for (Integer returnPoint : returnQueue) {
                if (returnPoint == startPoint) {
                    isAdded = true;
                    break;
                }
            }
            if (!isAdded) {
                returnQueue.enqueue(startPoint);
            }
        }
        return returnQueue;
    }

    /**
     * 取得該圖的反向圖
     * 
     * @return
     */
    private T158_Digraph reverse() {
        T158_Digraph reverseDigraph = new T158_Digraph(this.pointCount);
        for (int i = 0; i < this.adjList.length; i++) {
            Integer endPoint = i;
            for (Integer startPoint : this.adjList[i]) {
                reverseDigraph.addLine(startPoint, endPoint);
            }
        }
        return reverseDigraph;
    }

    @Override
    public String toString() {
        String returnFormat = "T158_Digraph [\n\tpointCount=%s, \n\t" + "lineCount=%s, \n\t" + "adjList=\n%s\n]";
        String queueFormat = "\t\t%s , T072_Queue [%s]";
        List<String> queueStrList = new ArrayList<String>();
        for (int i = 0; i < this.adjList.length; i++) {
            List<String> tempStrList = new ArrayList<String>();
            Iterator<Integer> iterator = this.adjList[i].iterator();
            while (iterator.hasNext()) {
                tempStrList.add(Integer.toString(iterator.next()));
            }
            queueStrList.add(String.format(queueFormat, i, String.join(", ", tempStrList)));
        }
        return String.format(returnFormat, this.pointCount, this.lineCount, String.join(", \n", queueStrList));
    }
}
```

## 🧠拓扑排序 Topological Sort
拓扑排序是用來排序一張有向圖的點的方式。把圖上一條由 A 點連向 B 點的邊，想成是 A 必須排在 B 前方。
==拓扑排序 = 有環判斷 + 頂點排序==
![[數據結構算法_05_圖_05_拓扑排序.png]]

### 檢測有向圖中的環
| 變量/方法 | API設計                                                                                                                                                                                               |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T160_DirectedCycle`                                                                                                                                                                                  |
| 構造方法  | `public T160_DirectedCycle(T158_Digraph digraph)`                                                                                                                                                     |
| 成員變量  | `private boolean[] isSearch`頂點是否被搜索過註記</br>`private boolean hasCycle`圖中是否有環</br>`private boolean[] onStack`索引代表頂點，使用棧的思想，記錄當前頂點有沒有已經處於正在搜索的有向路徑上 |
| 方法      | `public boolean hasCycle()`判斷圖中是否有環</br>`private void getConnectPoint(T158_Digraph digraph, int startPoint)`基於深度優先搜索，檢測圖中是否有環                                                |

```java
public class T160_DirectedCycle {
    // 頂點是否被搜索過註記
    private boolean[] isSearch;
    // 圖中是否有環
    private boolean hasCycle;
    // 索引代表頂點，使用棧的思想，記錄當前頂點有沒有已經處於正在搜索的有向路徑上
    private boolean[] onStack;

    public T160_DirectedCycle(T158_Digraph digraph) {
        super();
        this.isSearch = new boolean[digraph.getPointCount()];
        this.onStack = new boolean[digraph.getPointCount()];
        this.hasCycle = false;
        // 為防止圖多有子圖，因此將每個頂點都作為入口查找圖中的環
        for (int i = 0; i < this.isSearch.length; i++) {
            // 有搜索過就不用再找
            if (this.isSearch[i]) {
                continue;
            }
            this.getConnectPoint(digraph, i);
            // 若有搜索到環，不用再檢查
            if (this.hasCycle) {
                break;
            }
            // 頂點檢查完，將當前頂點出棧
            this.onStack[i] = false;
            for (int j = 0; j < this.onStack.length; j++) {
                this.onStack[j] = false;
            }
        }
    }

    /**
     * 判斷圖中是否有環
     * 
     * @return
     */
    public boolean hasCycle() {
        return this.hasCycle;
    }

    /**
     * 基於深度優先搜索，檢測圖中是否有環
     * 
     * @param digraph
     */
    private void getConnectPoint(T158_Digraph digraph, int startPoint) {
        this.isSearch[startPoint] = true;
        this.onStack[startPoint] = true;
        for (Integer nextPoint : digraph.getLineByStartPoint(startPoint)) {
            // 頂點存在棧中，代表圖中存在環
            if (this.onStack[nextPoint]) {
                this.hasCycle = true;
                return;
            }
            this.getConnectPoint(digraph, nextPoint);
        }
    }

    @Override
    public String toString() {
        return "T160_DirectedCycle ["//
                + "\n\tisSearch=" + Arrays.toString(isSearch) + ", "//
                + "\n\thasCycle=" + hasCycle + ", "//
                + "\n\tonStack=" + Arrays.toString(onStack) + //
                "\n]";
    }
}
```

### 頂點排序
當圖中無環時，就可以開始進行生成有序的線性隊列

| 變量/方法 | API設計                                                                                                                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T162_DepthFirstOrder`                                                                                                                                                                          |
| 構造方法  | `public T162_DepthFirstOrder(T158_Digraph digraph)`                                                                                                                                             |
| 成員變量  | `private boolean[] isSearch`頂點是否被搜索過註記</br>`private List<List<Integer>> reversePost`頂點路徑，一張圖可能為有多個路徑                                                                  |
| 方法      | `public List<Integer> reversePost(final int point)`獲取頂點棧序列</br>`private List<Integer> getOrderPoint(final T158_Digraph digraph, final int startPoint)`基於深度優先搜索，生成頂點棧性序列 |

```java
public class T162_DepthFirstOrder {
    // 頂點是否被搜索過註記
    private boolean[] isSearch;
    // 頂點路徑，一張圖可能為有多個路徑
    private List<List<Integer>> reversePost;

    public T162_DepthFirstOrder(final T158_Digraph digraph) throws Exception {
        super();
        this.isSearch = new boolean[digraph.getPointCount()];
        this.reversePost = new ArrayList<>();
        // 當圖中有環，則不進行後續動作
        if (new T160_DirectedCycle(digraph).hasCycle()) {
            throw new Exception("digraph have cycle.");
        }
        for (int i = 0; i < digraph.getPointCount(); i++) {
            // 新的路徑，將搜索註記初始化
            for (int j = 0; j < this.isSearch.length; j++) {
                this.isSearch[j] = false;
            }
            // 如果找過就不再找
            if (this.isSearch[i]) {
                continue;
            }
            this.reversePost.add(this.getOrderPoint(digraph, i));
        }
    }

    /**
     * 獲取頂點棧序列
     *
     * @return
     */
    public List<Integer> reversePost(final int point) {
        // 若超出查詢范圍
        if (point > this.reversePost.size()) {
            return new ArrayList<>();
        }
        return this.reversePost.get(point);
    }

    /**
     * 基於深度優先搜索，生成頂點棧性序列
     */
    private List<Integer> getOrderPoint(final T158_Digraph digraph, final int startPoint) {
        final List<Integer> returnStack = new ArrayList<>();
        // 有搜索過就不用再找
        if (this.isSearch[startPoint]) {
            return returnStack;
        }
        this.isSearch[startPoint] = true;
        returnStack.add(startPoint);
        for (final Integer nextPoint : digraph.getLineByStartPoint(startPoint)) {
            final List<Integer> subStack = this.getOrderPoint(digraph, nextPoint);
            for (final Integer point : subStack) {
                returnStack.add(point);
            }
        }
        return returnStack;
    }
}
```

# 加權無向圖
在無向圖的基礎上對邊進行加權，以代表距離或時間…等意義。

## 🧠加權無向邊類
| 變量/方法 | API設計                                                                                                                             |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T166_Edge`                                                                                                                         |
| 構造方法  | `T166_Edge(final int point1, final int point2, final double weight)`                                                                |
| 成員變量  | `private int point1`頂點1</br>`private int point2`頂點2</br>`private double weight`邊的權重                                         |
| 方法      | `public double getWeight()`</br>`public int getPoint1()`</br>`public int getPoint2()`</br>`public int compareTo(final T166_Edge o)` |

```java
public class T166_Edge implements Comparable<T166_Edge> {
    // 頂點1
    private int point1;
    // 頂點2
    private int point2;
    // 邊的權重
    private double weight;

	// getter & setter省略
	
    @Override
    public int compareTo(final T166_Edge o) {
        final double compare = this.weight - o.weight;
        if (compare > 0) {
            return 1;
        } else if (compare == 0) {
            return 0;
        } else {
            return -1;
        }
    }
}
```

## 🧠加權無向圖實現
| 變量/方法 | API設計                                                                                                                                                                                                                                                              |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T167_EdgeWeightGraph`                                                                                                                                                                                                                                               |
| 構造方法  | `T167_EdgeWeightGraph(final int pointCount)`                                                                                                                                                                                                                         |
| 成員變量  | `private int pointCount`頂點數量</br>`private int lineCount`邊數量</br>`private T072_Queue<T166_Edge>[] adjList`鄰接表                                                                                                                                               |
| 方法      | `public int getPointCount()`</br>`public int getLineCount()`</br>`public void addEdge(final T166_Edge edge)`兩頂點間新增邊</br>`public T072_Queue<T166_Edge> getLineByPoint(final int point)`取得指定頂點的邊</br>`public T072_Queue<T166_Edge> getLine()`取得所有邊 |

```java
public class T167_EdgeWeightGraph {
    // 頂點數量
    private int pointCount;
    // 邊數量
    private int lineCount;
    // 鄰接表
    private T072_Queue<T166_Edge>[] adjList;

    public T167_EdgeWeightGraph(final int pointCount) {
        super();
        this.pointCount = pointCount;
        this.lineCount = 0;
        this.adjList = new T072_Queue[pointCount];
        for (int i = 0; i < this.adjList.length; i++) {
            this.adjList[i] = new T072_Queue<>();
        }
    }

    public int getPointCount() {
        return this.pointCount;
    }

    public int getLineCount() {
        return this.lineCount;
    }

    /**
     * 兩頂點間新增邊
     *
     * @param edge
     */
    public void addEdge(final T166_Edge edge) {
        // 兩頂點必須在鄰接表中
        if (edge.getPoint1() >= this.adjList.length || edge.getPoint2() >= this.adjList.length) {
            return;
        }
        // 兩頂點必須相互沒連接
        final Iterator<T166_Edge> iterator1 = this.adjList[edge.getPoint1()].iterator();
        while (iterator1.hasNext()) {
            final T166_Edge iteratorEdge = iterator1.next();
            if ((edge.getPoint1() == iteratorEdge.getPoint1() && edge.getPoint2() == iteratorEdge.getPoint2()) || //
                    (edge.getPoint2() == iteratorEdge.getPoint2() && edge.getPoint1() == iteratorEdge.getPoint2())) {
                return;
            }
        }
        final Iterator<T166_Edge> iterator2 = this.adjList[edge.getPoint2()].iterator();
        while (iterator2.hasNext()) {
            final T166_Edge iteratorEdge = iterator2.next();
            if ((edge.getPoint1() == iteratorEdge.getPoint1() && edge.getPoint2() == iteratorEdge.getPoint2()) || //
                    (edge.getPoint2() == iteratorEdge.getPoint2() && edge.getPoint1() == iteratorEdge.getPoint2())) {
                return;
            }
        }
        // 兩頂點新增邊
        this.adjList[edge.getPoint1()].enqueue(edge);
        this.adjList[edge.getPoint2()].enqueue(edge);
        this.lineCount++;
    }

    /**
     * 取得指定頂點的邊
     *
     * @param point
     * @return
     */
    public T072_Queue<T166_Edge> getLineByPoint(final int point) {
        return this.adjList[point];
    }

    /**
     * 取得所有邊
     *
     * @return
     */
    public T072_Queue<T166_Edge> getLine() {
        final T072_Queue<T166_Edge> returnQueue = new T072_Queue<>();
        for (int i = 0; i < this.adjList.length; i++) {
            final Iterator<T166_Edge> iterator = this.adjList[i].iterator();
            while (iterator.hasNext()) {
                final T166_Edge edge = iterator.next();
                // 檢查邊已經有加進去，則不再重覆加入
                boolean hasAdded = false;
                final Iterator<T166_Edge> returnIterator = returnQueue.iterator();
                while (returnIterator.hasNext()) {
                    final T166_Edge returnEdge = returnIterator.next();
                    if ((edge.getPoint1() == returnEdge.getPoint1() && edge.getPoint2() == returnEdge.getPoint2()) || //
                            (edge.getPoint2() == returnEdge.getPoint1() && edge.getPoint1() == returnEdge.getPoint2())) {
                        hasAdded = true;
                        break;
                    }
                }
                if (hasAdded) {
                    continue;
                }
                returnQueue.enqueue(edge);
            }
        }
        return returnQueue;
    }

    @Override
    public String toString() {
        final String returnFormat = "T167_EdgeWeightGraph [\n\tpointCount=%s, \n\t" + "lineCount=%s, \n\t" + "adjList=\n%s\n]";
        final String queueFormat = "\t\t%s , T072_Queue [%s]";
        final List<String> queueStrList = new ArrayList<String>();
        for (int i = 0; i < this.adjList.length; i++) {
            final List<String> tempStrList = new ArrayList<String>();
            final Iterator<T166_Edge> iterator = this.adjList[i].iterator();
            while (iterator.hasNext()) {
                tempStrList.add(iterator.next().toString());
            }
            queueStrList.add(String.format(queueFormat, i, String.join(", ", tempStrList)));
        }
        return String.format(returnFormat, this.pointCount, this.lineCount, String.join(", \n", queueStrList));
    }
}
```

## 🧠最小生成樹 Minimum Spanning Tree
1. 所有頂點都是連通的
2. 起點和終點不能是同一個(不能成為環)
3. 起點到終點的權重總和最少就是最小生成樹
4. 最小生成權邊的數量 = 頂點數 - 1

### 樹的性質
![[數據結構算法_05_圖_06_最小生成樹.png]]
1. 用一條邊接樹中任意兩個頂點都會得到一個環
2. 任意刪除一個邊，會得到兩個獨立的樹

### 切分定理
![[數據結構算法_05_圖_07_切分定理.png]]
- 相關概念：
	- 切分：把圖中頂點分成兩個部分
	- 橫切邊：如果一個邊連接兩個頂點分別屬於切分的兩個部分
	- 切分定理：橫切邊中權重最小的邊必須屬於最小生成樹

### 貪心算法
使用切分定理找最小生成樹的一條邊，不斷重覆，直到找到最小生成樹的所有邊；貪心算法是最小生成樹算法中的基礎。

![[數據結構算法_05_圖_08_貪心算法.png]]

### Prim算法
將最小生成樹中的頂點看作一部分，而不在最小生成樹看作另一部分，每個步驟將一個頂點加入到最小生成樹中
![[數據結構算法_05_圖_09_Prim算法.png]]

| 變量/方法 | API設計                                                                                                                                                                                              |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T172_PrimMST`                                                                                                                                                                                       |
| 構造方法  | `T172_PrimMST(final T167_EdgeWeightGraph graph)`                                                                                                                                                     |
| 成員變量  | `private T166_Edge[] edgeToMinTree`索引代表頂點，值代表頂點到最小生成樹間的最短邊                                                                                                                    |
| 方法      | `private void pushPointToMinTree(final T167_EdgeWeightGraph graph, final int point)`將指定頂點加入最小生成樹，並更新成員變量</br>`public T072_Queue<T166_Edge> getMinTreeEdge()`取得最小生成樹所有邊 |

```java
public class T172_PrimMST {
    // 索引代表頂點，值代表頂點到最小生成樹間的最短邊
    private T166_Edge[] edgeToMinTree;

    public T172_PrimMST(final T167_EdgeWeightGraph graph) {
        super();
        this.edgeToMinTree = new T166_Edge[graph.getPointCount()];
        // 默認頂點0先進最小生成樹
        this.edgeToMinTree[0] = new T166_Edge(0, 0, 0);
        this.pushPointToMinTree(graph, 0);
    }

    /**
     * 將指定頂點加入最小生成樹，並更新成員變量
     *
     * @param graph
     * @param point
     */
    private void pushPointToMinTree(final T167_EdgeWeightGraph graph, final int point) {
        // 取得與頂點相連的邊
        final T113_IndexMinPriorityQueue<T166_Edge> betweenLineQueue = new T113_IndexMinPriorityQueue<>(graph.getLineCount());
        final Iterator<T166_Edge> pointIterator = graph.getLineByPoint(point).iterator();
        while (pointIterator.hasNext()) {
            final T166_Edge edge = pointIterator.next();
            // 如果另一個頂點已經檢查過，則不加入檢查隊列
            if ((edge.getPoint1() == point && this.edgeToMinTree[edge.getPoint2()] != null) || //
                    (edge.getPoint2() == point && this.edgeToMinTree[edge.getPoint1()] != null)) {
                continue;
            }
            betweenLineQueue.insert((int) edge.getWeight(), edge);
        }
        // 從最小邊開始加入最小生成樹
        while (betweenLineQueue.size() != 0) {
            final T166_Edge minEdge = betweenLineQueue.getElement();
            final int otherPoint = minEdge.getPoint1() != point ? minEdge.getPoint1() : minEdge.getPoint2();
            // 如果頂點已加入生成樹，則跳過
            if (this.edgeToMinTree[otherPoint] != null) {
                continue;
            }
            this.edgeToMinTree[otherPoint] = minEdge;
            this.pushPointToMinTree(graph, otherPoint);
        }
    }

    /**
     * 取得最小生成樹所有邊
     *
     * @return
     */
    public T072_Queue<T166_Edge> getMinTreeEdge() {
        final T072_Queue<T166_Edge> queue = new T072_Queue<>();
        for (final T166_Edge edge : this.edgeToMinTree) {
            queue.enqueue(edge);
        }
        return queue;
    }
}
```

### kruskal算法
把圖中的分成多顆樹，每個步驟將兩顆樹樹連成一顆樹

| 變量/方法 | API設計                                                                                                                                                                                              |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T172_PrimMST`                                                                                                                                                                                       |
| 構造方法  | `T172_PrimMST(final T167_EdgeWeightGraph graph)`                                                                                                                                                     |
| 成員變量  | `private T166_Edge[] edgeToMinTree`索引代表頂點，值代表頂點到最小生成樹間的最短邊                                                                                                                    |
| 方法      | `private void pushPointToMinTree(final T167_EdgeWeightGraph graph, final int point)`將指定頂點加入最小生成樹，並更新成員變量</br>`public T072_Queue<T166_Edge> getMinTreeEdge()`取得最小生成樹所有邊 |

```java
public class T178_KruskalMST {
    // 最小生成樹的所有邊
    private T072_Queue<T166_Edge> minTree;
    // 使用并查集的概念來判斷兩個頂點是否在同一個樹中
    private T140_UnionFindTreePathless graphUnionFind;
    // 圖中所有邊
    private T110_MinPriorityQueue<T166_Edge> allLine;

    public T178_KruskalMST(final T167_EdgeWeightGraph graph) {
        super();
        this.minTree = new T072_Queue<>();
        this.graphUnionFind = new T140_UnionFindTreePathless(graph.getPointCount());
        // 儲存圖中所有邊
        this.allLine = new T110_MinPriorityQueue<>(graph.getLineCount());
        for (final T166_Edge edge : graph.getLine()) {
            this.allLine.insert(edge);
        }
        this.pushToMinTree(graph);
    }

    /**
     * 生成最小生成樹
     *
     * @param graph
     */
    private void pushToMinTree(final T167_EdgeWeightGraph graph) {
        while (!this.allLine.isEmpty() || this.minTree.getLen() >= graph.getPointCount() - 1) {
            final T166_Edge edge = this.allLine.getElement();
            // 如果兩點在同一顆樹，則跳過
            final int point1 = edge.getPoint1();
            final int point2 = edge.getPoint2();
            if (this.graphUnionFind.connected(point1, point2)) {
                continue;
            }
            // 加到最小生成樹
            this.minTree.enqueue(edge);
            // 將兩點并成一顆樹
            this.graphUnionFind.doUnion(point1, point2);
        }
    }

    public T072_Queue<T166_Edge> getMinTreeEdge() {
        return this.minTree;
    }
}
```

# 加權有向圖
## 🧠加權有向邊類
| 變量/方法 | API設計                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------- |
| 類        | `T180_DirectedEdge`                                                                             |
| 構造方法  | `T180_DirectedEdge(final int startPoint, final int endPoint, final double weight)`              |
| 成員變量  | `private int startPoint`起點</br>`private int endPoint`終點</br>`private double weight`邊的權重 |
| 方法      | `public double getWeight()`</br>`public int getStartPoint()`</br>`public int getEndPoint()`     |

```java
public class T180_DirectedEdge {
    private int startPoint;
    private int endPoint;
    private double weight;
}
```

## 🧠加權有向圖實現
| 變量/方法 | API設計                                                                                                                                                                                                                                                              |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T167_EdgeWeightGraph`                                                                                                                                                                                                                                               |
| 構造方法  | `T167_EdgeWeightGraph(final int pointCount)`                                                                                                                                                                                                                         |
| 成員變量  | `private int pointCount`頂點數量</br>`private int lineCount`邊數量</br>`private T072_Queue<T166_Edge>[] adjList`鄰接表                                                                                                                                               |
| 方法      | `public int getPointCount()`</br>`public int getLineCount()`</br>`public void addEdge(final T166_Edge edge)`兩頂點間新增邊</br>`public T072_Queue<T166_Edge> getLineByPoint(final int point)`取得指定頂點的邊</br>`public T072_Queue<T166_Edge> getLine()`取得所有邊 |

```java
public class T181_EdgeWeightDigraph {
    // 頂點數量
    private int pointCount;
    // 邊數量
    private int lineCount;
    // 鄰接表
    private T072_Queue<T180_DirectedEdge>[] adjList;

    public T181_EdgeWeightDigraph(final int pointCount) {
        super();
        this.pointCount = pointCount;
        this.lineCount = 0;
        this.adjList = new T072_Queue[pointCount];
        for (int i = 0; i < this.adjList.length; i++) {
            this.adjList[i] = new T072_Queue<T180_DirectedEdge>();
        }
    }

    public int getPointCount() {
        return this.pointCount;
    }

    public int getLineCount() {
        return this.lineCount;
    }

    public void addEdge(final T180_DirectedEdge edge) {
        // 兩頂點必須在鄰接表中
        if (edge.getStartPoint() >= this.adjList.length || edge.getEndPoint() >= this.adjList.length) {
            return;
        }
        // 兩頂點必須相互沒連接
        final Iterator<T180_DirectedEdge> startIterator = this.adjList[edge.getStartPoint()].iterator();
        while (startIterator.hasNext()) {
            if (startIterator.next().getEndPoint() == edge.getEndPoint()) {
                return;
            }
        }
        // 在起點新增邊
        this.adjList[edge.getStartPoint()].enqueue(edge);
        this.lineCount++;
    }

    /**
     * 取得指定頂點的邊
     *
     * @param point
     * @return
     */
    public T072_Queue<T180_DirectedEdge> getLineByPoint(final int point) {
        return this.adjList[point];
    }

    /**
     * 取得所有邊
     *
     * @return
     */
    public T072_Queue<T180_DirectedEdge> getLine() {
        final T072_Queue<T180_DirectedEdge> returnQueue = new T072_Queue<>();
        for (final T072_Queue<T180_DirectedEdge> queue : this.adjList) {
            final Iterator<T180_DirectedEdge> iterator = queue.iterator();
            while (iterator.hasNext()) {
                returnQueue.enqueue(iterator.next());
            }
        }
        return returnQueue;
    }
}
```

## 🧠最短路徑
- 為了簡化問題，以下只考慮連通圖，也就是兩個頂點一定在圖中相連

### 鬆弛技術 Dijkstra
找指定點到所有點的最短路徑，以下參考：
<iframe width="560" height="315" src="https://www.youtube.com/embed/NLp9C7AvJhk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

| 變量/方法 | API設計                                                                                                                                                                                                                                                                                                                                           |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 類        | `T184_DijkstraMST`                                                                                                                                                                                                                                                                                                                                |
| 構造方法  | `T184_DijkstraMST(final T181_EdgeWeightDigraph graph, final int startPoint)`                                                                                                                                                                                                                                                                      |
| 成員變量  | `private T180_DirectedEdge[] pointPreEdge`起點到指定點的最小路徑中的最後一條邊</br>`private double[] toPointWeight`起點到頂點的總權重                                                                                                                                                                                                             |
| 方法      | `private void doRelax(final T181_EdgeWeightDigraph graph, final int point)`鬆弛圖中指定點</br>`public double getToPointWeight(final int point)`取得起點到指定點的總權重</br>`public boolean hasPathTo(final int point)`判斷起點到指定頂點是否可抵達</br>`public T072_Queue<T180_DirectedEdge> getPath(int point)`取得起點到指定點最小路徑的所有邊 |

```java
public class T184_DijkstraMST {
    // 起點到指定點的最小路徑中的最後一條邊
    private T180_DirectedEdge[] pointPreEdge;
    // 起點到頂點的總權重
    private double[] toPointWeight;

    /**
     * @param graph 加權有向圖
     * @param startPoint 起點
     */
    public T184_DijkstraMST(final T181_EdgeWeightDigraph graph, final int startPoint) {
        super();
        this.pointPreEdge = new T180_DirectedEdge[graph.getPointCount()];
        this.toPointWeight = new double[graph.getPointCount()];
        for (int i = 0; i < this.toPointWeight.length; i++) {
            this.toPointWeight[i] = Double.POSITIVE_INFINITY;// 塞最大值，以便後續比較
        }
        // 找到起點的最小路徑樹
        this.toPointWeight[startPoint] = 0;
        this.doRelax(graph, startPoint);
    }

    /**
     * 鬆弛圖中指定點
     *
     * @param graph
     * @param point
     */
    private void doRelax(final T181_EdgeWeightDigraph graph, final int point) {
        // 取得與頂點相連的邊
        for (final T180_DirectedEdge edge : graph.getLineByPoint(point)) {
            final int endPoint = edge.getEndPoint();
            // 起點->中間點->終點的權重 小於 起點->終點的權重
            if (this.getToPointWeight(point) + edge.getWeight() < this.getToPointWeight(endPoint)) {
                this.toPointWeight[endPoint] = this.getToPointWeight(point) + edge.getWeight();
                this.pointPreEdge[endPoint] = edge;
                // 如果最小路徑邊存在權重，則更新；反之則新增
                this.doRelax(graph, endPoint);
            }
        }
    }

    /**
     * 取得起點到指定點的總權重
     *
     * @param point
     * @return
     */
    public double getToPointWeight(final int point) {
        return this.toPointWeight[point];
    }

    /**
     * 判斷起點到指定頂點是否可抵達
     *
     * @param point
     * @return
     */
    public boolean hasPathTo(final int point) {
        return this.toPointWeight[point] < Double.POSITIVE_INFINITY;
    }

    /**
     * 取得起點到指定點最小路徑的所有邊
     *
     * @param point
     * @return
     */
    public T072_Queue<T180_DirectedEdge> getPath(int point) {
        final T072_Queue<T180_DirectedEdge> returnQueue = new T072_Queue<T180_DirectedEdge>();
        // 起點到指定頂點必須可達
        if (!this.hasPathTo(point)) {
            return returnQueue;
        }
        // 從指定頂點向前找
        while (true) {
            final T180_DirectedEdge preEdge = this.pointPreEdge[point];
            // 若為起點，上一個頂點為null
            if (preEdge == null) {
                break;
            }
            returnQueue.enqueue(preEdge);
            point = preEdge.getStartPoint();
        }
        return returnQueue;
    }
}
```
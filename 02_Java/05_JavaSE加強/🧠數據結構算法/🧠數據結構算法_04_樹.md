#💻編程/🌠Java/05_JavaSE加強 
# 樹 Tree
- 有層次關系
- 常見術語：
	- 結點的度：一個結點含有的子樹的數量
	- 根結點：無父節點的結點
	- 葉結點：度為0的結點
	- 結點的層次：從根結點開始，根結點的層次為1，根的直屬子結點為2，以此類推…
	- 結點的層序編號：將樹中結點，由上層到下層、同層由左到右排成線性序列
	- 樹的度：樹中所有結點的度的最大值
	- 樹的高度：樹中結點的最大層次

![image](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Treedatastructure.png/300px-Treedatastructure.png)

# 二叉樹 Binary tree
每個節點最多只有兩個分支
![image](https://i.iter01.com/images/8af979f68af40b98a26b37b1aa4325c1d77f6e1e289a48820d583795e97e518c.png)

## 🧠二叉查找樹結點
|變量/方法|API設計|
|---|---|
|構造方法|`T082_TreeNode(final K key, final V value)`|
|變量|`public K key`樹以鍵值對儲存</br>`public V value`</br>`public T082_TreeNode<K, V> leftNode`左結點</br>`public T082_TreeNode<K, V> rightNode`右結點|

```java
public class T082_TreeNode<K, V> {
    // 以鍵值對儲存
    public K key;
    public V value;
    // 左結點
    public T082_TreeNode<K, V> leftNode;
    // 右結點
    public T082_TreeNode<K, V> rightNode;
    private String printTab = "\t\t";

    public T082_TreeNode(final K key, final V value, final T082_TreeNode<K, V> leftNode, final T082_TreeNode<K, V> rightNode) {
        super();
        this.key = key;
        this.value = value;
        this.leftNode = leftNode;
        this.rightNode = rightNode;
    }
	
	// toString()省略
}
```

## 🧠二叉查找樹
左子節點 < 父節點 < 右子節點
`T082_BinaryTree<K extends Comparable<K>, V>`

|變量/方法|API設計|
|---|---|
|構造方法|`T082_BinaryTree()`|
|變量|`private T082_TreeNode<K, V> rootNode`根結點</br>`private int lenght`樹中元素個數|
|方法|`void put(K key, V value)`向樹添加鍵值對</br>`T082_TreeNode<K, V> put(T082_TreeNode<K, V> treeNode, K key, V value)`</br>向指定樹上添加鍵值對，返回添加後的新樹</br>`V get(final K key)`依鍵找值</br>`V get(T082_TreeNode<K, V> treeNode, K key)`按鍵向指定樹找值</br>`void delete(K key)`依鍵刪除結點</br>`void delete(T082_TreeNode<K, V> treeNode, K key)`刪除指定樹中指定鍵的結點</br>`int getLen()`|

```java
public class T082_BinaryTree<K extends Comparable<K>, V> {
    // 根結點
    private T082_TreeNode<K, V> rootNode;
    // 樹中元素個數
    private int lenght;
}
```

### 添加結點邏輯
1. 當前結點 == null，添加結點
2. 新結點 < 當前結點，繼續查找當前結點的"左"結點
3. 新結點 == 當前結點，替換值即可
4. 新結點 > 當前結點，繼續查找當前結點的"右"結點

```java
public void put(final K key, final V value) {
	this.rootNode = this.put(this.rootNode, key, value);
	this.lenght++;
}

private T082_TreeNode<K, V> put(T082_TreeNode<K, V> treeNode, final K key, final V value) {
	// 若指定樹的根結點為空
	if (treeNode == null || treeNode.key == null) {
		treeNode = new T082_TreeNode<K, V>(key, value, null, null);
		return treeNode;
	}
	// 鍵大於結點，放至右節點
	if (key.compareTo(treeNode.key) > 0) {
		treeNode.rightNode = this.put(treeNode.rightNode, key, value);
	}
	// 鍵等於結點，更新值
	else if (key.compareTo(treeNode.key) == 0) {
		treeNode.value = value;
		this.lenght--;
	}
	// 鍵小於結點，放至左節點
	else {
		treeNode.leftNode = this.put(treeNode.leftNode, key, value);
	}
	return treeNode;
}
```

### 查找結點邏輯
和添加類似

```java
public V get(final K key) {
	return this.get(this.rootNode, key);
}

private V get(final T082_TreeNode<K, V> treeNode, final K key) {
	V returnValue = null;
	if (treeNode == null || treeNode.key == null) {
		return returnValue;
	}
	// 鍵大於結點，至右節點找值
	if (key.compareTo(treeNode.key) > 0) {
		returnValue = this.get(treeNode.rightNode, key);
	}
	// 鍵等於結點，返回值
	else if (key.compareTo(treeNode.key) == 0) {
		returnValue = treeNode.value;
	}
	// 鍵小於結點，至左節點找值
	else {
		returnValue = this.get(treeNode.leftNode, key);
	}
	return returnValue;
}
```

### 刪除結點邏輯
![image](https://img-blog.csdnimg.cn/20190330115253130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2U4OTEzNzc=,size_16,color_FFFFFF,t_70)

1. 找到替代刪除結點的結點
	- 若有右子樹，找右子樹最小結點
	- 若無右子樹 && 有左子樹，找左子樹最大結點
	- 若左、右子樹都沒有，直接刪除結點
2. 要注意
	- 若最小結點有右子樹，需要將右子樹內容向上一層移
	- 反之若最大結點有左子樹，也要上移左子樹
3. 刪除結點，並用替換結點替換

```java
public void delete(final K key) {
	this.rootNode = this.delete(this.rootNode, key);
}

/**
 * 刪除指定樹中指定鍵的結點
 *
 * @param treeNode
 * @param key
 */
private T082_TreeNode<K, V> delete(T082_TreeNode<K, V> treeNode, final K key) {
	// 若指定節點為空，不做處理
	if (treeNode == null || treeNode.key == null) {
		return null;
	}
	// 找到要刪除的結點
	if (key.compareTo(treeNode.key) > 0) {
		treeNode.rightNode = this.delete(treeNode.rightNode, key);
	} else if (key.compareTo(treeNode.key) == 0) {
		// 找要替代的結點
		T082_TreeNode<K, V> newTreeNode = null;
		// 若有左結點，則取左結點的最大值
		if (treeNode.leftNode != null) {
			newTreeNode = this.findAndReplaceMaxNode(treeNode.leftNode);
		}
		// 若無左結點，則取右結點的最小值
		else if (treeNode.rightNode != null) {
			newTreeNode = this.findAndReplaceMinNode(treeNode.leftNode);
		}
		// 若有左、右結點再更新
		if (newTreeNode != null) {
			newTreeNode.rightNode = treeNode.rightNode;
			newTreeNode.leftNode = treeNode.leftNode;
		}
		treeNode = newTreeNode;
		this.lenght--;
	} else {
		treeNode.leftNode = this.delete(treeNode.leftNode, key);
	}
	return treeNode;
}

/**
 * 找指定樹中最大節點，並替換成根結點(給刪除用)
 *
 * @param treeNode
 * @return
 */
private T082_TreeNode<K, V> findAndReplaceMaxNode(T082_TreeNode<K, V> treeNode) {
	// 若右結點不為空，繼續找
	if (treeNode.rightNode != null) {
		final T082_TreeNode<K, V> maxNode = this.findAndReplaceMaxNode(treeNode.rightNode);
		// 最大值的上一層節點，右結點為最大節點的左節點
		if (treeNode.rightNode.equals(maxNode)) {
			treeNode.rightNode = maxNode.leftNode;
		}
		// 將最大結點指定為父結點
		maxNode.rightNode = treeNode;
		treeNode = maxNode;
	}
	return treeNode;
}

/**
 * 找指定樹中最小節點，並替換成根結點(給刪除用)
 *
 * @param treeNode
 * @return
 */
private T082_TreeNode<K, V> findAndReplaceMinNode(T082_TreeNode<K, V> treeNode) {
	// 若左結點不為空，繼續找
	if (treeNode.rightNode != null) {
		final T082_TreeNode<K, V> minNode = this.findAndReplaceMinNode(treeNode.leftNode);
		// 最小值的上一層節點，左結點為最小節點的右節點
		if (treeNode.leftNode.equals(minNode)) {
			treeNode.leftNode = minNode.rightNode;
		}
		// 將最小結點指定為父結點
		minNode.leftNode = treeNode;
		treeNode = minNode;
	}
	return treeNode;
}
```

### 查找最小鍵
|`T082_TreeNode<K, V> getMinNode()`|取得樹中最小節點|
|---|---|
|`T082_TreeNode<K, V> getMinNode(T082_TreeNode<K, V> treeNode)`|取得指定樹的最小節點|

```java
/**
 * 找指定樹中最小節點，並替換成根結點(給刪除用)
 *
 * @param treeNode
 * @return
 */
private T082_TreeNode<K, V> findAndReplaceMinNode(T082_TreeNode<K, V> treeNode) {
	// 若左結點不為空，繼續找
	if (treeNode.rightNode != null) {
		final T082_TreeNode<K, V> minNode = this.findAndReplaceMinNode(treeNode.leftNode);
		// 最小值的上一層節點，左結點為最小節點的右節點
		if (treeNode.leftNode.equals(minNode)) {
			treeNode.leftNode = minNode.rightNode;
		}
		// 將最小結點指定為父結點
		minNode.leftNode = treeNode;
		treeNode = minNode;
	}
	return treeNode;
}

public T082_TreeNode<K, V> getMinNode() {
	return this.getMinNode(this.rootNode);
}

/**
 * 取得指定樹的最小節點
 *
 * @param treeNode
 * @return
 */
private T082_TreeNode<K, V> getMinNode(T082_TreeNode<K, V> treeNode) {
	if (treeNode == null) {
		return null;
	}
	if (treeNode.leftNode != null) {
		treeNode = this.getMinNode(treeNode.leftNode);
	}
	return treeNode;
}

public T082_TreeNode<K, V> getMaxNode() {
	return this.getMaxNode(this.rootNode);
}
```

### 查找最大鍵
|`T082_TreeNode<K, V> getMaxNode()`|取得樹中最大節點|
|---|---|
|`T082_TreeNode<K, V> getMaxNode(T082_TreeNode<K, V> treeNode)`|取得指定樹的最大節點|

和查找最小鍵類似，筆記省略

### 遍歷
按照搜索路徑進行遍歷


```java
/**
 * 前序遍歷
 *
 * @return
 */
public T072_Queue<K> preErgodic() {
	return this.preErgodic(this.rootNode);
}

/**
 * 將指定樹執行前序遍歷
 * 根節點-->左子樹-->右子樹
 *
 * @param treeNode
 * @return
 */
private T072_Queue<K> preErgodic(final T082_TreeNode<K, V> treeNode) {
	final T072_Queue<K> returnQueue = new T072_Queue<K>();
	// 根節點
	// 節點鍵為空，代表也沒有左、右子樹
	if (treeNode.key == null) {
		return new T072_Queue<K>();
	}
	returnQueue.enqueue(treeNode.key);
	// 左子樹
	final T072_Queue<K> leftQueue = (treeNode.leftNode != null) ? this.preErgodic(treeNode.leftNode) : new T072_Queue<K>();
	while (leftQueue.getLen() > 0) {
		returnQueue.enqueue(leftQueue.dequeue());
	}
	// 右子樹
	final T072_Queue<K> rightQueue = (treeNode.rightNode != null) ? this.preErgodic(treeNode.rightNode) : new T072_Queue<K>();
	while (rightQueue.getLen() > 0) {
		returnQueue.enqueue(rightQueue.dequeue());
	}
	return returnQueue;
}
```

#### 前序遍歷
根節點-->左子樹-->右子樹

#### 中序遍歷(重要)
左子樹-->根節點-->右子樹
```
和前序遍歷類似
```

#### 後序遍歷
左子樹-->右子樹-->根節點
```
和前序遍歷類似
```

#### 層序遍歷
根節點(第一層)-->第二層-->……-->第N層
```java
/**
 * 層序遍歷
 *
 * @return
 */
public T072_Queue<K> layerErgodic() {
	return this.layerErgodic(this.rootNode);
}

/**
 * 層序遍歷
 * 根節點(第一層)-->第二層-->………-->第n層
 *
 * @param treeNode
 * @return
 */
private T072_Queue<K> layerErgodic(final T082_TreeNode<K, V> treeNode) {
	final T072_Queue<K> returnQueue = new T072_Queue<K>();
	final T072_Queue<T082_TreeNode<K, V>> tempQueue = new T072_Queue<T082_TreeNode<K, V>>();
	tempQueue.enqueue(treeNode);
	while (!tempQueue.isEmpty()) {
		final T082_TreeNode<K, V> findNode = tempQueue.dequeue();
		if (findNode.leftNode != null) {
			tempQueue.enqueue(findNode.leftNode);
		}
		if (findNode.rightNode != null) {
			tempQueue.enqueue(findNode.rightNode);
		}
		returnQueue.enqueue(findNode.key);
	}
	return returnQueue;
}
```

### 最大深度問題
```java
/**
 * 取得樹的最大深度
 *
 * @return
 */
public int getMaxDepth() {
	return this.getMaxDepth(this.rootNode);
}

/**
 * 取得指定樹的最大深度
 *
 * @param treeNode
 * @return
 */
private int getMaxDepth(final T082_TreeNode<K, V> treeNode) {
	if (treeNode == null) {
		return 0;
	}
	final int leftDepth = (treeNode.leftNode == null) ? 0 : this.getMaxDepth(treeNode.leftNode);
	final int rightDepth = (treeNode.rightNode == null) ? 0 : this.getMaxDepth(treeNode.rightNode);
	return (leftDepth >= rightDepth) ? leftDepth + 1 : rightDepth + 1;
}
```

### 折紙問題
- 問題描述：
	![images](https://img-blog.csdnimg.cn/20200419110201685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01vZWxpbW9l,size_16,color_FFFFFF,t_70)
- 分析為程序問題：
	- 根節點為下節點
	- 所有節點的左子節點都為下折痕
	- 所有節點的右子節點都為上折痕
	- 以中序遍歷打印折衰
	![images](https://img-blog.csdnimg.cn/2020041911024852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01vZWxpbW9l,size_16,color_FFFFFF,t_70)

```java
@Test
@DisplayName("二叉樹_折紙問題")
public void testcase02() {
	// TODO 折紙次數，相當於樹的深度
	final int num = 4;
	if (num <= 0) {
		System.out.println("請輸入正確的析紙次數");
	}
	// 第一次折紙，一定為down
	final T082_TreeNode<Integer, String> rootNode = new T082_TreeNode<Integer, String>(1, "down", null, null);
	final T072_Queue<T082_TreeNode<Integer, String>> depthQueue = new T072_Queue<T082_TreeNode<Integer, String>>();
	depthQueue.enqueue(rootNode);
	for (int i = 2; i <= num; i++) {
		// 取得下一層的所有節點
		final int queueLen = depthQueue.getLen();
		for (int j = 0; j < queueLen; j++) {
			final T082_TreeNode<Integer, String> node = depthQueue.dequeue();
			// 左子節點都為down
			final T082_TreeNode<Integer, String> leftNode = new T082_TreeNode<Integer, String>(i, "down", null, null);
			node.leftNode = leftNode;
			depthQueue.enqueue(leftNode);
			// 右子節點都為up
			final T082_TreeNode<Integer, String> rightNode = new T082_TreeNode<Integer, String>(i, "up", null, null);
			node.rightNode = rightNode;
			depthQueue.enqueue(rightNode);
		}
	}
	// 使用中序遍歷打印折痕類型
	final T072_Queue<T082_TreeNode<Integer, String>> midQueue = this.midErgodic(rootNode);
	while (midQueue.getLen() > 0) {
		final T082_TreeNode<Integer, String> node = midQueue.dequeue();
		System.out.println(node.printInfo());
	}
}

/**
 * 中序遍歷
 * 左子樹-->根節點-->右子樹
 *
 * @param treeNode
 * @return
 */
private T072_Queue<T082_TreeNode<Integer, String>> midErgodic(final T082_TreeNode<Integer, String> treeNode) {
	final T072_Queue<T082_TreeNode<Integer, String>> returnQueue = new T072_Queue<T082_TreeNode<Integer, String>>();
	// 鍵為空，表示無左、右子樹
	if (treeNode == null) {
		return new T072_Queue<T082_TreeNode<Integer, String>>();
	}
	// 左子樹
	final T072_Queue<T082_TreeNode<Integer, String>> leftQueue = (treeNode.leftNode != null) ? //
			this.midErgodic(treeNode.leftNode) : new T072_Queue<T082_TreeNode<Integer, String>>();
	while (leftQueue.getLen() > 0) {
		returnQueue.enqueue(leftQueue.dequeue());
	}
	// 根節點
	returnQueue.enqueue(treeNode);
	// 右子樹
	final T072_Queue<T082_TreeNode<Integer, String>> rightQueue = (treeNode.rightNode != null) ? //
			this.midErgodic(treeNode.rightNode) : new T072_Queue<T082_TreeNode<Integer, String>>();
	while (rightQueue.getLen() > 0) {
		returnQueue.enqueue(rightQueue.dequeue());
	}
	return returnQueue;
}
```

## 🧠堆 Heap
- 特點：
	1. 堆為完全二叉樹；除最後一層可以不滿外，其他每一層都都必須是滿的；若最後一層不是滿的，則必須左滿右不滿
		![完全二叉樹](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8bd9afc7d91410985bf46f34ddf3432~tplv-k3u1fbpfcp-zoom-1.image)
	2. 通常表現為數組
		- 若節點為`list[k]`，則子節點為`list[2k]`和`list[2k+1]`
		![堆數組](https://img-blog.csdn.net/20151113213424274)
	3. 每個節點都大於等於子節點，而子節點順序無規定

### 添加、刪除元素
|變量/方法|API設計|
|---|---|
|類|`T097_Heap<T extends Comparable<T>>`|
|構造方法|`public T097_Heap(int size)`|
|變量|`private T[] elements`</br>`private int size`|
|方法|`public T deleteMax()`刪除堆中的最大元素，並返回此元素</br>`public void insert(T element)`在堆中插入元素</br>`private void swim(int index)`使用上浮算法，比父節點大則向上移</br>`private void sink(int index)`使用下沉算法，比較大的子節點小則下移</br>`private boolean isLess(int i, int j)`判斷兩個索引值大小</br>`private void changeLocation(int i, int j)`交換兩個索引值|

```java
public class T097_Heap<T extends Comparable<T>> {
	private T[] elements;
	private int size;

	/**
	 * 建立指定容量的堆
	 */
	public T097_Heap(int size) {
		super();
		this.elements = (T[]) new Comparable[size];
		this.size = 0;
	}

	/**
	 * 刪除堆中的最大元素，並返回此元素
	 */
	public T deleteMax() {
		// 堆中無元素，不執行
		if (size <= 0) {
			return null;
		}
		// 交換根節點、最後一個節點
		this.changeLocation(0, size - 1);
		// 刪除最後一個節點
		T delElement = this.elements[size--];
		this.elements[size] = null;
		// 將第一個元素排序(下沉算法)
		this.sink(0);
		return delElement;
	}

	/**
	 * 在堆中插入元素
	 */
	public void insert(T element) {
		// 增加長度
		if (this.elements.length <= size + 1) {
			T[] newElements = (T[]) new Comparable[this.elements.length * 2];
			for (int i = 0; i < this.elements.length; i++) {
				newElements[i] = this.elements[i];
			}
			this.elements = newElements;
		}
		// 將新元素放至最後再進行排序(上浮算法)
		this.elements[size] = element;
		this.swim(size++);
	}

	/**
	 * 使用上浮算法，比父節點大則向上移
	 */
	private void swim(int index) {
        // 索引為根節點不用比較
        if (index == 0) {
            return;
        }
        // 索引為左子節點
        if (index % 2 != 0) {
            final int supIndex = (index - 1) / 2;
            if (this.isLess(index, supIndex)) {
                this.changeLocation(index, supIndex);
                this.swin(supIndex);
            }
        }
        // 索引為右子節點
        else {
            final int supIndex = (index - 2) / 2;
            if (this.isLess(index, supIndex)) {
                this.changeLocation(index, supIndex);
                this.swin(supIndex);
            }
        }
	}

	/**
	 * 使用下沉算法，比較大的子節點小則下移
	 */
	private void sink(int index) {
		int subIndex01 = index * 2 + 1;
		int subIndex02 = index * 2 + 2;
		// 無子節點可以比較
		if (subIndex01 >= this.size) {
			return;
		}
		// 較大子節點為左子節點，且大於父節點
		if ((subIndex02 >= this.size || this.isLess(subIndex01, subIndex02)) && this.isLess(subIndex01, index)) {
			this.changeLocation(subIndex01, index);
			this.sink(subIndex01);
		}
		// 較大子節點為右子節點，且大於父節點
		else if (subIndex02 < this.size && (this.isLess(subIndex02, subIndex01) && this.isLess(subIndex02, index))) {
			this.changeLocation(subIndex02, index);
			this.sink(subIndex02);
		}
	}

	/**
	 * 判斷兩個索引值大小；true，i的索引值較大；false，兩者一樣大或j的索引值較大
	 */
	private boolean isLess(int i, int j) {
		return this.elements[i].compareTo(this.elements[j]) > 0;
	}

	/**
	 * 交換兩個索引值
	 */
	private void changeLocation(int i, int j) {
		T temp = this.elements[i];
		this.elements[i] = this.elements[j];
		this.elements[j] = temp;
	}

	@Override
	public String toString() {
		return "T097_Heap [elements=" + Arrays.toString(elements) + ", size=" + size + "]";
	}
}
```

### 排序
- `Comparable[] createHaep(final Comparable[] source)`，根據數組構造成堆
- `Comparable[] doSort(final Comparable[] source)`，數組以小到大排序

```java
public class T102_HeapSort {
    /**
     * 根據數組構造成堆
     */
    public static Comparable[] createHaep(final Comparable[] source) {
        if (source == null) {
            return null;
        }
        // 建立堆數組
        final Comparable[] returnHeap = Arrays.copyOf(source, source.length);
        // 對堆數組前一半的元素進行下沉排序
        for (int heapIndex = returnHeap.length / 2; heapIndex >= 0; heapIndex--) {
            T102_HeapSort.sink(returnHeap, heapIndex, returnHeap.length - heapIndex - 1);
        }
        return returnHeap;
    }

    /**
     * 數組以小到大排序
     */
    public static Comparable[] doSort(final Comparable[] source) {
        if (source == null) {
            return null;
        }
        // 建立堆數組
        final Comparable[] heap = T102_HeapSort.createHaep(source);
        for (int changeIndex = heap.length - 1; changeIndex > 0; changeIndex--) {
            // 最大值及最小值索引交換
            T102_HeapSort.changeLocation(heap, 0, changeIndex);
            // 將索引0的元素進行下沉排序，排序范圍需跳過最後索引
            T102_HeapSort.sink(heap, 0, changeIndex - 1);
        }
        return heap;
    }

    /**
     * 將指定索引在指定笵圍中下沉排序(大-->小)
     */
    private static void sink(final Comparable[] source, final int index, final int range) {
        final int subIndex01 = index * 2 + 1;
        final int subIndex02 = index * 2 + 2;
        // 超過比較范圍
        if (range <= 0 || index + range < subIndex01) {
            return;
        }
        // 無子節點比較
        if (subIndex01 >= source.length) {
            return;
        }
        // 較大子節點為左子節點，且大於父節點
        if (subIndex02 >= source.length || index + range < subIndex02
                || (T102_HeapSort.isLess(source, subIndex01, subIndex02) && T102_HeapSort.isLess(source, subIndex01, index))) {
            T102_HeapSort.changeLocation(source, subIndex01, index);
            T102_HeapSort.sink(source, subIndex01, range - subIndex01);
        }
        // 較大子節點為右子節點，且大於父節點
        else if (T102_HeapSort.isLess(source, subIndex02, subIndex01) && T102_HeapSort.isLess(source, subIndex02, index)) {
            T102_HeapSort.changeLocation(source, subIndex02, index);
            T102_HeapSort.sink(source, subIndex02, range - subIndex02);
        }
    }

    /**
     * 判斷兩個索引值大小；true，i的索引值較大；false，兩者一樣大或j的索引值較大
     */
    private static boolean isLess(final Comparable[] source, final int i, final int j) {
        return source[i].compareTo(source[j]) > 0;
    }

    /**
     * 交換兩個索引值
     */
    private static void changeLocation(final Comparable[] source, final int i, final int j) {
        final Comparable temp = source[i];
        source[i] = source[j];
        source[j] = temp;
    }
}
```

## 🧠優先隊列 Priority Queue
[[🧠數據結構算法_02_線性表]]中的隊列只能拿出最先進入隊列的元素，優先隊列則是基於堆的數據結構，每次取出的元素一定為隊列中優先級最大值(或是最小值)。

### 最大優先隊列 Max Priority Queue
做法和實現堆差不多：
- 插入元素後用上浮算法排序
- 取出最大元素(根節點)後用最後索引的值補上，再用下沉算法排序

### 最小優先隊列  Min Priority Queue
和最大優先隊列差不多：
- 最小值放在根元素
- 父節點元素一定小於子節點元素
- 主要調整`isLess(int i, int j)`的判斷

### 索引優先隊列 Index Min Priority Queue
最大/最小優先隊列都僅能取出最大/最小值進行修改，無法取得指定索引的值，因此索引優先隊列將索引都對應鍵(在隊列子儲的位置)。

![image](https://img-blog.csdnimg.cn/20200510153114796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY2MzY3NQ==,size_16,color_FFFFFF,t_70)

- 內容列表，內容索引<-->內容元素
- 隊列列表，以隊列的方式對內容排序，隊列索引<-->內容索引
- 隊列索引列表，為了方便從內容找到隊列索引，內容索引<-->隊列索引

```java
/**
 * 最小索引優先隊列
 * (最大索引優先隊列的做法類似)
 *
 * @param <T>
 */
public class T113_IndexMinPriorityQueue<T extends Comparable<T>> {
    // 內容列表，內容索引<-->內容元素
    private T[] elements;
    // 隊列列表，以隊列的方式對內容排序，隊列索引<-->內容索引
    private int[] queueElements;
    // 隊列索引列表，為了方便從內容找到隊列索引，內容索引<-->隊列索引
    private int[] queueIndexs;
    private int size;

    public T113_IndexMinPriorityQueue(final int size) {
        super();
        this.size = 0;
        this.elements = (T[]) new Comparable[size];
        this.queueElements = new int[size];
        this.queueIndexs = new int[size];
    }

    /**
     * 取得最小值
     *
     * @return
     */
    public T getElement() {
        // 無元素可取
        if (this.size == 0) {
            return null;
        }
        // 取得返回元素並清空
        final T returnElement = this.elements[this.queueElements[0]];
        this.elements[this.queueElements[0]] = null;
        this.queueIndexs[this.queueElements[0]] = 0;
        this.queueElements[0] = 0;
        // 將最後元素放至根節點，並執行下沉排序
        this.size--;
        this.changeLocation(0, this.size);
        this.sink(0);
        return returnElement;
    }

    /**
     * 向指定索引插入元素
     *
     * @param index 內容索引
     * @param element 內容元素
     */
    public void insert(final int index, final T element) {
        // 內容列表的索引已經有值，不再插入
        if (this.contains(index)) {
            return;
        }
        // 內容列表長度不夠，則需要擴容
        if (index >= this.elements.length) {
            final T[] newElements = (T[]) new Comparable[index * 2];
            for (int i = 0; i < this.elements.length; i++) {
                newElements[i] = this.elements[i];
            }
            this.elements = newElements;
            // 隊列索引列表也要一起擴容
            final int[] newQueueIndexs = new int[index * 2];
            for (int i = 0; i < this.queueIndexs.length; i++) {
                newQueueIndexs[i] = this.queueIndexs[i];
            }
            this.queueIndexs = newQueueIndexs;
        }
        // 將元素放至內容列表
        this.elements[index] = element;
        // 隊列列表長度不夠，則需要擴容
        if (this.queueElements.length < this.size + 1) {
            final int[] newQueueElements = new int[this.queueElements.length * 2];
            for (int i = 0; i < this.queueElements.length; i++) {
                newQueueElements[i] = this.queueElements[i];
            }
            this.queueElements = newQueueElements;
        }
        // 將內容索引放至隊列列表最後，並進行上浮排序
        this.queueElements[this.size] = index;
        this.queueIndexs[index] = this.size;
        this.swim(this.size++);
    }

    /**
     * 判斷索引對應元素是否存在
     *
     * @param index
     * @return
     */
    public boolean contains(final int index) {
        if (index >= this.elements.length) {
            return false;
        }
        return this.elements[index] != null;
    }

    /**
     * 針對指定隊列索引執行上浮排序
     *
     * @param queueIndex
     */
    private void swim(final int queueIndex) {
        // 根節點不需比對
        if (queueIndex == 0) {
            return;
        }
        // 索引為左子節點
        if (queueIndex % 2 != 0) {
            final int supIndex = (queueIndex - 1) / 2;
            if (this.isLess(queueIndex, supIndex)) {
                this.changeLocation(queueIndex, supIndex);
                this.swim(supIndex);
            }
        }
        // 索引為右子節點
        else {
            final int supIndex = (queueIndex - 2) / 2;
            if (this.isLess(queueIndex, supIndex)) {
                this.changeLocation(queueIndex, supIndex);
                this.swim(supIndex);
            }
        }
    }

    /**
     * 針對指定隊列索引執行下沉排序
     *
     * @param queueIndex
     */
    private void sink(final int queueIndex) {
        final int leftIndex = queueIndex * 2 + 1;
        final int rightIndex = queueIndex * 2 + 2;
        // 無左子節點
        if (leftIndex >= this.size) {
            return;
        }
        // 左子節點比右子節點大 或 無右子節點
        if ((rightIndex >= this.size || this.isLess(leftIndex, rightIndex)) && this.isLess(leftIndex, queueIndex)) {
            this.changeLocation(queueIndex, leftIndex);
            this.sink(leftIndex);
        }
        // 右子節點比左子節點大
        else if (rightIndex < this.size && this.isLess(rightIndex, leftIndex) && this.isLess(rightIndex, queueIndex)) {
            this.changeLocation(queueIndex, rightIndex);
            this.sink(rightIndex);
        }
    }

    /**
     * 若j較大為true，若i較大為false
     *
     * @param i
     * @param j
     * @return
     */
    private boolean isLess(final int i, final int j) {
        return this.elements[this.queueElements[j]].compareTo(this.elements[this.queueElements[i]]) > 0;
    }

    /**
     * 交換元素索引位置
     *
     * @param i
     * @param j
     */
    private void changeLocation(final int i, final int j) {
        // 交換內容索引
        final int tempElement = this.queueElements[i];
        this.queueElements[i] = this.queueElements[j];
        this.queueElements[j] = tempElement;
        // 交換隊列索引
        this.queueIndexs[this.queueElements[i]] = i;
        this.queueIndexs[this.queueElements[j]] = j;
    }

    @Override
    public String toString() {
        return "T113_IndexMinPriorityQueue [\n" //
                + "\telements=" + Arrays.toString(this.elements) + ", \n"//
                + "\tqueueElements=" + Arrays.toString(this.queueElements) + ", \n" //
                + "\tqueueIndexs=" + Arrays.toString(this.queueIndexs) + ", \n" //
                + "\tsize=" + this.size + "\n"//
                + "]";
    }
}
```

## 🧠2-3查找樹
為了查詢效能，要將樹的層級降低(轉為完成二叉樹)，從而引入2-3查找樹的概念，它含有2個、3個節點，為了使任意空節點到根節點的長度是相等的。雖然可以不用在程式中實現此邏輯，但紅黑樹、B樹、B+樹都是基於2-3查找樹的概念！！
- [什麼是2-3查找樹 知乎](https://zhuanlan.zhihu.com/p/92394224)
- [2-3查找樹插入流程講解 bilibili](https://www.bilibili.com/video/BV1iJ411E7xW?p=121)

![image](https://pic4.zhimg.com/80/v2-b782a4f8712559d3a461da3fe891b58f_720w.jpg)

- 2-節點：邏輯和二叉樹一樣，比父節點小找左子節點，比父節點大找右子節點
- 3-節點：父節點有兩個鍵
	- 比兩個鍵都小，找左子節點
	- 介於兩個鍵之間，找中間子節點
	- 比兩個鍵都大，找右子節點

## 🧠紅黑樹 R-B Tree
- 定義：紅黑樹是基於二叉樹實現2-3查找樹，也就是說用黑鏈結、紅鏈結來表示2-節點、3-節點
	- 黑鏈結：一個普通的二叉節點
	- 紅鏈結：兩個2-節點組成一個3-節點
- 特點：
	1. 釭鏈結都為左鏈接
	2. 一個節點最多只能有一條紅鏈結
	3. 黑色平衡，即任意空鏈結到根節點路徑相同

![image](https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/2-3%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91-%E6%95%B4%E4%BD%93%E5%AF%B9%E6%AF%94.png)

|變量/方法|API設計|
|---|---|
|類|`T124_Node<Key, Value>`|
|構造方法|`public T124_Node(Key key, Value value, Node subLeft, Node subRight, boolean color)`|
|成員變量|`public Node subLeft`，左子節點</br>`public Node subRight`，右子節點</br>`public Key key`</br>`public Value value`</br>`public boolean color`其父結點指向它的鏈結，false為黑，true為紅顏色|

### 平衡化
- 平衡化：當紅黑樹進行增刪改操作後，可能不能滿足紅黑樹的特點，所以需要進行操作(左旋/右旋)來保持樹的平衡
- 左旋：當節點的左子節點為黑色、右子節點為紅色，則需要左旋。
	![image](https://pic2.zhimg.com/80/v2-30474dff9eacac87d6694c14793ca171_720w.jpg)
- 右旋：當節點的左子節點為紅色，左子節點的左子節點也為左色，則需要右旋。
	但右旋後會出現節點的左、右子節點都為紅，同樣不滿足紅黑樹特性，此時右旋不處理，另外還需要進行顏色反轉。
	![image](https://pic4.zhimg.com/80/v2-c28bd346c5c793730e81ad9d68a74943_720w.jpg)
- 顏色反轉：左節點的左、右子節點都為紅色時，則需要顏色反轉；相當於柝分4-節點。
	![image](https://pic1.zhimg.com/80/v2-924e46534463feda7ec6b5086123c648_720w.jpg)

### 實現
|變量/方法|API設計|
|---|---|
|類|`T128_RedBlackTree<Key extends Comparable<Key>, Value>`|
|構造方法|`T128_RedBlackTree()`|
|成員變量|`private T124_Node<Key, Value> rootNode`</br>`private int size`</br>`private static final boolean RED = true`紅色鏈接標識，因為Node的color可讀性不高</br>`private static final boolean BLACK = false`黑色鏈接標識，因為Node的color可讀性不高|
|方法|`public void put(Key key, Value value)`在整個樹插入元素</br>`private T124_Node<Key, Value> put(T124_Node<Key, Value> node, Key key, Value value)`在指定樹插入元素，返回添加完元素後的樹</br>`public Value get(Key key)`根據key找值</br>`private Value get(T124_Node<Key, Value>node, Key key)`判斷結點的父節點指向節點是否為紅鏈結|

```java
public class T128_RedBlackTree<Key extends Comparable<Key>, Value> {
    private T124_Node<Key, Value> rootNode;
    private int size;
    // 紅色鏈接標識，因為Node的color可讀性不高
    private static final boolean RED = true;
    // 黑色鏈接標識，因為Node的color可讀性不高
    private static final boolean BLACK = false;

    public T128_RedBlackTree() {
        super();
        this.size = 0;
    }

    /**
     * 在整個樹插入元素
     *
     * @param key
     * @param value
     */
    public void put(final Key key, final Value value) {
        this.rootNode = this.put(this.rootNode, key, value);
        this.rootNode.color = BLACK;// 根節點一定為黑鏈結
    }

    /**
     * 在指定樹插入元素
     *
     * @return 添加完元素後的樹
     */
    private T124_Node<Key, Value> put(T124_Node<Key, Value> node, final Key key, final Value value) {
        // 若節點為空，直拉返回紅鏈結的節點
        if (node == null) {
            this.size++;
            return new T124_Node(key, value, null, null, RED);
        }
        final int condition = key.compareTo(node.key);
        // key和節點相等，替換value即可
        if (condition == 0) {
            node.value = value;
        }
        // key比較小，找左子節點
        else if (condition < 0) {
            node.subLeftNode = this.put(node.subLeftNode, key, value);
        }
        // key比較大，找右子節點
        else if (condition > 0) {
            node.subRightNode = this.put(node.subRightNode, key, value);
        }
        // 若左子節點為黑鏈結、右子節點為紅鏈結，執行左旋
        if (this.isRed(node.subRightNode)) {
            node = this.rotateLeft(node);
        }
        // 若左子節點為紅鏈結，且左子節點的左子節點也為左鏈結，執行右旋
        if (this.isRed(node.subLeftNode) //&& this.isBlack(node.subRightNode)
                && this.isRed(node.subLeftNode.subLeftNode)) {
            node = this.rotateRight(node);
        }
        // 若左、右子節點為紅鏈結，執行顏色反轉
        if (this.isRed(node.subLeftNode) && this.isRed(node.subRightNode)) {
            node = this.flipColor(node);
        }
        return node;
    }

    /**
     * 根據key找值
     *
     * @param key
     * @return
     */
    public Value get(final Key key) {
        return this.get(this.rootNode, key);
    }

    /**
     * 在指定樹，根據key找值，查找方式和二叉樹一樣
     *
     * @param node
     * @param key
     * @return
     */
    private Value get(final T124_Node<Key, Value> node, final Key key) {
        if (node == null) {
            return null;
        }
        final int condition = node.key.compareTo(key);
        if (condition < 0) {
            return this.get(node.subRightNode, key);
        } else if (condition > 0) {
            return this.get(node.subLeftNode, key);
        } else {
            return node.value;
        }
    }

    /**
     * 左旋
     *
     * @param node 不符合紅黑樹特性的節點
     * @return
     */
    private T124_Node<Key, Value> rotateLeft(final T124_Node<Key, Value> node) {
        final T124_Node<Key, Value> newSupNode = node.subRightNode;
        node.subRightNode = newSupNode.subLeftNode;
        node.color = newSupNode.color;
        newSupNode.subLeftNode = node;
        newSupNode.color = BLACK;
        return newSupNode;
    }

    /**
     * 右旋
     *
     * @param node
     * @return
     */
    private T124_Node<Key, Value> rotateRight(final T124_Node<Key, Value> node) {
        final T124_Node<Key, Value> newSubNode = node.subLeftNode;
        node.subLeftNode = newSubNode.subRightNode;
        node.color = newSubNode.color;
        newSubNode.subRightNode = node;
        newSubNode.color = BLACK;
        return newSubNode;
    }

    /**
     * 顏色反轉，拆分4-節點
     *
     * @param node
     * @return
     */
    private T124_Node<Key, Value> flipColor(final T124_Node<Key, Value> node) {
        node.color = !node.color;
        node.subLeftNode.color = !node.subLeftNode.color;
        node.subRightNode.color = !node.subRightNode.color;
        return node;
    }

    /**
     * 判斷結點的父節點指向節點是否為紅鏈結
     *
     * @param node
     * @return
     */
    private boolean isRed(final T124_Node<Key, Value> node) {
        if (node == null) {
            return false;
        }
        return node.color == RED;
    }

    private boolean isBlack(final T124_Node<Key, Value> node) {
        if (node == null) {
            return false;
        }
        return node.color == BLACK;
    }

    @Override
    public String toString() {
        return "T128_RedBlackTree [rootNode=" + this.rootNode + ", size=" + this.size + "]";
    }
}
```

# 多叉樹 Multiway Trees
## 🧠B樹
B樹中節點可以包含多個key，具體有幾個key主要看具體的實現，因此在實現B樹時必須指定參數M來確定B樹所含的key，可以稱作M階的B樹。

![image](https://img-blog.csdn.net/20160202204827368)

- 特點：
	1. 每個節點最多有M-1個key，並以升序排列
	2. 最個節點最多有M個子結點
	3. 根節點至少有兩個子結點(這樣才平衡)
- 增刪操作原理：[B樹的插入和刪除步驆](https://www.cnblogs.com/nullzx/p/8729425.html)
- [B樹在磁盤讀寫的應用](https://www.bilibili.com/video/BV1iJ411E7xW?p=133)

## 🧠B+樹
![image](https://img-blog.csdn.net/20160202205105560)

- B+樹為B樹的一種變形，差異：
	1. B+樹存在非葉結點，非葉結點僅具有索引作用，只存key不存value
	2. B+樹的葉節點是以有序鏈表組成(可參考：[[🧠數據結構算法_02_線性表]])，方便遍歷
- B+樹操作數據原理：[ B+樹插入](https://www.bilibili.com/video/BV1iJ411E7xW?p=134)
- [B+樹在數據庫的應用](https://www.bilibili.com/video/BV1iJ411E7xW?p=135)

## 🧠并查集 Union Find
- 合并、查詢的集合，可以高效執行：
	1. 查詢兩元素是否在同一組
	2. 合并兩元素作在的組
- 特點
	1. 每個元素對應一個節點
	2. 每組數據都為一顆樹
	3. 兩組數據間無任何關系
	4. 同組內節點的父子關系無要求

![[數據結構算法_04_樹_01_并查集.png]]

### 基本實現
|變量/方法|API設計|
|---|---|
|類|`T137_UnionFind`|
|構造方法|`T137_UnionFind(int size)`|
|成員變量|`private int[] eleAndGroup`記錄節點元素和該元素所在分組的標識符</br>`private int groupCount`數組的分組個數|
|方法|`public int getGroupCount()`取得分組個數</br>`public boolean connected(int element1, int element2)`判斷兩元素是否存在同一組中</br>`public int find(int element)`取得元素所在的分組標識符</br>`public void doUnion(int element1, int element2)`合并兩個元素所在的分組|

```java
public class T137_UnionFind {
    // 記錄節點元素和該元素所在分組的標識符
    private int[] eleAndGroup;
    // 數組的分組個數
    private int groupCount;

    public T137_UnionFind(int size) {
        super();
        // 初始情況下，每個元素都在獨立的分組中，所以數組分為size個組
        this.groupCount = size;
        // 初始化eleAndGroup，建立長度為size
        this.eleAndGroup = new int[size];
        // 將每個元素作為分組標識符，並將元素都作為每個組的根節點
        for (int i = 0; i < this.eleAndGroup.length; i++) {
            this.eleAndGroup[i] = i;
        }
    }

    /**
     * 取得分組個數
     * 
     * @return
     */
    public int getGroupCount() {
        return this.groupCount;
    }

    /**
     * 判斷兩元素是否存在同一組中
     * 
     * @param element1
     * @param element2
     * @return
     */
    public boolean connected(int element1, int element2) {
        // 如果兩元素的分組標識符相同，代表在同一組
        return this.find(element1) == this.find(element2);
    }

    /**
     * 取得元素所在的分組標識符
     * 
     * @param element
     * @return
     */
    public int find(int element) {
        return this.eleAndGroup[element];
    }

    /**
     * 合并兩個元素所在的分組
     * 
     * @param element1
     * @param element2
     */
    public void doUnion(int element1, int element2) {
        // 兩元素若在同一分組，直接返回
        if (this.connected(element1, element2)) {
            return;
        }
        // 將element1的組標識符改為和element2一致
        int elementGroup1 = this.find(element1);
        int elementGroup2 = this.find(element2);
        for (int i = 0; i < this.eleAndGroup.length; i++) {
            if (this.eleAndGroup[i] == elementGroup1) {
                this.eleAndGroup[i] = elementGroup2;
            }
        }
        // 更新分組個數
        this.groupCount--;
    }
}
```

### 優化-使用樹的概念
主要優化find和doUnion方法，doUnion從O(n)變為O(1)，但find郤從O(1)變為O(n)

|變量/方法|API設計|
|---|---|
|類|`T139_UnionFindTree`|
|構造方法|`T139_UnionFindTree(int size)`|
|成員變量|`private int[] eleAndGroup`==記錄節點元素與其父節點==</br>`private int groupCount`數組的分組個數|
|方法|`public int getGroupCount()`取得分組個數</br>`public boolean connected(int element1, int element2)`判斷兩元素是否存在同一組中</br>`public int find(int element)`取得元素所在的分組標識符，也就是找根節點</br>`public void doUnion(int element1, int element2)`合并兩個元素所在的分組|

![image](https://www.runoob.com/wp-content/uploads/2020/10/rank-01.png)

```java
/**
 * 取得元素所在的分組標識符，也就是找根節點
 * 
 * @param element
 * @return
 */
public int find(int element) {
	int returnElement = -1;
	// 元素大於分組標識符數組長度
	if (element >= this.eleAndGroup.length) {
		return returnElement;
	}
	returnElement = element;
	while (true) {
		int supElement = this.eleAndGroup[returnElement];
		// 自己為自己的父節點，表示此節點為根節點
		if (supElement == returnElement) {
			break;
		}
		// 還有父節點，則繼續找
		else {
			returnElement = supElement;
		}
	}
	return returnElement;
}

/**
 * 合并兩個元素所在的分組
 * 
 * @param element1
 * @param element2
 */
public void doUnion(int element1, int element2) {
	// 兩元素若在同一分組，直接返回
	if (this.connected(element1, element2)) {
		return;
	}
	// 將element1的父節點改為和element2一致
	this.eleAndGroup[element1] = element2;
	// 更新分組個數
	this.groupCount--;
}
```

### 優化-路徑壓縮
執行兩組合并(doUnion)時是粗暴地將兩組合并，應先判斷兩組的大小，再將小組并到大組中，這樣可以壓縮樹的路徑。

|變量/方法|API設計|
|---|---|
|類|`T140_UnionFindTreePathless`|
|構造方法|`T140_UnionFindTreePathless(int size)`|
|成員變量|`private int[] eleAndGroup`記錄節點元素與其父節點</br>`private int[] eleSubSize`==記錄節點對應樹的節點數==</br>`private int groupCount`數組的分組個數|
|方法|`public int getGroupCount()`取得分組個數</br>`public boolean connected(int element1, int element2)`判斷兩元素是否存在同一組中</br>`public int find(int element)`取得元素所在的分組標識符，也就是找根節點</br>`public void doUnion(int element1, int element2)`合并兩個元素所在的分組，==較小組合并至較大組==|

```java
/**
 * 合并兩元素的組，較小組合并至較大組
 *
 * @param element1
 * @param element2
 */
public void doUnion(final int element1, final int element2) {
	// 兩元素若在同一分組，直接返回
	if (this.connected(element1, element2)) {
		return;
	}
	// 取得兩元素根節點及其對應的節點數
	int rootBigger = this.find(element2);// 默認元素2為較大組
	int rootSmaller = this.find(element1);
	final int elementRootSize1 = this.eleSubSize[rootBigger];
	final int elementRootSize2 = this.eleSubSize[rootSmaller];
	// 如果元素1的根節點為較大組，則交換
	if (elementRootSize1 < elementRootSize2) {
		final int temp = rootBigger;
		rootBigger = rootSmaller;
		rootSmaller = temp;
	}
	// 較少組并入較大組
	this.eleAndGroup[rootSmaller] = rootBigger;
	// 更新較大組對應的樹節點數
	this.eleSubSize[rootBigger] += this.eleSubSize[rootSmaller];
	// 更新較大組根節點的樹節點數
	if (rootBigger != this.find(rootBigger)) {
		this.eleSubSize[this.find(rootBigger)] += this.eleSubSize[rootSmaller];
	}
	// 更新分組個數
	this.groupCount--;
}
```

